// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --replace-value-regex "!annotation ![0-9]+" "!tbaa ![0-9]+" "!tbaa\.struct ![0-9]+" "!nosanitize ![0-9]+" "!srcloc ![0-9]+" --version 5
// RUN: %clang_cc1 -O2 -triple arm64-apple-iphoneos -fbounds-safety -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O2 -triple arm64-apple-iphoneos -fbounds-safety -x objective-c -fbounds-attributes-objc-experimental -emit-llvm %s -o - | FileCheck %s


#include <ptrcheck.h>

typedef struct {
  int count;
  int elems[];
} flex_t;

// CHECK-LABEL: define dso_local void @test_under_base_fail(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[ARR:%.*]] = alloca [20 x i8], align 1
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 20, ptr nonnull [[ARR]]) #[[ATTR7:[0-9]+]]
// CHECK-NEXT:    [[BOUND_PTR_ARITH:%.*]] = getelementptr i8, ptr [[ARR]], i64 -1
// CHECK-NEXT:    [[DOTNOT:%.*]] = icmp eq ptr [[BOUND_PTR_ARITH]], null, {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[DOTNOT]], label %[[CONT8:.*]], label %[[BOUNDSCHECK_NOTNULL:.*]], {{!annotation ![0-9]+}}
// CHECK:       [[BOUNDSCHECK_NOTNULL]]:
// CHECK-NEXT:    [[UPPER:%.*]] = getelementptr inbounds nuw i8, ptr [[ARR]], i64 20
// CHECK-NEXT:    [[TMP0:%.*]] = icmp ult ptr [[BOUND_PTR_ARITH]], [[UPPER]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[TMP1:%.*]] = icmp uge ptr [[BOUND_PTR_ARITH]], [[ARR]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[OR_COND:%.*]] = and i1 [[TMP0]], [[TMP1]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[OR_COND]], label %[[CONT8]], label %[[TRAP:.*]], {{!annotation ![0-9]+}}
// CHECK:       [[TRAP]]:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR8:[0-9]+]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       [[CONT8]]:
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 20, ptr nonnull [[ARR]]) #[[ATTR7]]
// CHECK-NEXT:    ret void
//
void test_under_base_fail() {
  char arr[20];
  char *oob_ptr = arr - 1;
  flex_t *__single flex = (flex_t *)oob_ptr;
}

// CHECK-LABEL: define dso_local void @test_under_base_ok(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR3:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    ret void
//
void test_under_base_ok() {
  char arr[20];
  char *oob_ptr = arr - 1;
  flex_t *flex = (flex_t *)oob_ptr;
}


// CHECK-LABEL: define dso_local void @test_under_base_fail2(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[ARR:%.*]] = alloca [20 x i8], align 1
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 20, ptr nonnull [[ARR]]) #[[ATTR7]]
// CHECK-NEXT:    [[BOUND_PTR_ARITH:%.*]] = getelementptr i8, ptr [[ARR]], i64 -1
// CHECK-NEXT:    [[DOTNOT:%.*]] = icmp ugt ptr [[ARR]], [[BOUND_PTR_ARITH]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[DOTNOT]], label %[[TRAP:.*]], label %[[CONT8:.*]], {{!annotation ![0-9]+}}
// CHECK:       [[TRAP]]:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR8]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       [[CONT8]]:
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 20, ptr nonnull [[ARR]]) #[[ATTR7]]
// CHECK-NEXT:    ret void
//
void test_under_base_fail2() {
  char arr[20];
  char *oob_ptr = arr - 1;
  flex_t *flex = (flex_t *)oob_ptr;
  int a = flex->count;
}


// CHECK-LABEL: define dso_local void @test_over_base_fail(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR4:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR8]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void test_over_base_fail() {
  char arr[20];
  char *oob_ptr = arr + 20;
  flex_t *__single flex = (flex_t *)oob_ptr;
}

// CHECK-LABEL: define dso_local void @test_over_base_ok(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR3]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    ret void
//
void test_over_base_ok() {
  char arr[20];
  char *oob_ptr = arr + 20;
  flex_t *flex = (flex_t *)oob_ptr;
}

// CHECK-LABEL: define dso_local void @test_over_base_fail2(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[ARR:%.*]] = alloca [20 x i8], align 1
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 20, ptr nonnull [[ARR]]) #[[ATTR7]]
// CHECK-NEXT:    [[UPPER:%.*]] = getelementptr inbounds nuw i8, ptr [[ARR]], i64 20
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr [[ARR]], i64 24
// CHECK-NEXT:    [[DOTNOT:%.*]] = icmp ugt ptr [[TMP0]], [[UPPER]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[DOTNOT]], label %[[TRAP:.*]], label %[[CONT8:.*]], {{!annotation ![0-9]+}}
// CHECK:       [[TRAP]]:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR8]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       [[CONT8]]:
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 20, ptr nonnull [[ARR]]) #[[ATTR7]]
// CHECK-NEXT:    ret void
//
void test_over_base_fail2() {
  char arr[20];
  char *oob_ptr = arr + 20;
  flex_t *flex = (flex_t *)oob_ptr;
  int a = flex->count;
}

// FIXME: rdar://84809738
// CHECK-LABEL: define dso_local void @test_small_base_fail(
// CHECK-SAME: ptr nocapture noundef readnone [[FLEX:%.*]]) local_unnamed_addr #[[ATTR3]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    ret void
//
void test_small_base_fail(flex_t *flex) {
  char arr[3];
  flex = (flex_t *)arr;
}

// CHECK-LABEL: define dso_local void @test_small_base_ok(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR3]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    ret void
//
void test_small_base_ok() {
  char arr[3];
  flex_t *flex = (flex_t *)arr;
}

// CHECK-LABEL: define dso_local void @test_small_base_fail2(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR3]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    ret void
//
void test_small_base_fail2() {
  char arr[3];
  flex_t *flex = (flex_t *)arr;
  (void)(*flex);
}

// CHECK-LABEL: define dso_local void @test_base_only_ok(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR3]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    ret void
//
void test_base_only_ok() {
  char arr[20];
  flex_t *__single flex = (flex_t *)arr;
}

// CHECK-LABEL: define dso_local void @test_count_from_buf_ok(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR3]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    ret void
//
void test_count_from_buf_ok() {
  char arr[4];
  flex_t *__single flex = (flex_t *)arr;
}

// CHECK-LABEL: define dso_local void @test_count_from_buf_ok2(
// CHECK-SAME: ptr nocapture noundef readnone [[FLEX:%.*]]) local_unnamed_addr #[[ATTR3]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    ret void
//
void test_count_from_buf_ok2(flex_t *flex) {
  char arr[4];
  flex = (flex_t *)arr;
}

// FIXME: rdar://84809738
// CHECK-LABEL: define dso_local void @test_count_from_buf_fail(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR3]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    ret void
//
void test_count_from_buf_fail() {
  char arr[3];
  flex_t *__single flex = (flex_t *)arr;
}

// CHECK-LABEL: define dso_local void @test_base_count_ok(
// CHECK-SAME: ptr nocapture noundef readnone [[FLEX:%.*]]) local_unnamed_addr #[[ATTR3]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    ret void
//
void test_base_count_ok(flex_t *__single flex) {
  char arr[20];
  flex = (flex_t *)arr;
  (void)flex->count;
}

// CHECK-LABEL: define dso_local void @test_base_fam_access_fail(
// CHECK-SAME: ptr nocapture noundef readnone [[FLEX:%.*]]) local_unnamed_addr #[[ATTR4]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR8]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void test_base_fam_access_fail(flex_t *__single flex) {
  char arr[20];
  flex = (flex_t *)arr;
  flex->elems[0] = 0;
}

// CHECK-LABEL: define dso_local void @test_base_fam_access_fail2(
// CHECK-SAME: ptr nocapture noundef readnone [[FLEX:%.*]]) local_unnamed_addr #[[ATTR4]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR8]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void test_base_fam_access_fail2(flex_t *__single flex) {
  char arr[20];
  flex = (flex_t *)arr;
  flex->elems[1] = 0;
}

// FIXME: rdar://80820825
// CHECK-LABEL: define dso_local void @test_null_base_fail(
// CHECK-SAME: ptr nocapture noundef readnone [[FLEX:%.*]]) local_unnamed_addr #[[ATTR5:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    unreachable
//
void test_null_base_fail(flex_t *__single flex) {
  flex = 0;
  flex->count = 4;
}

// CHECK-LABEL: define dso_local void @test_null_base_ok(
// CHECK-SAME: ptr nocapture noundef readnone [[FLEX:%.*]]) local_unnamed_addr #[[ATTR3]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    ret void
//
void test_null_base_ok(flex_t *__single flex) {
  flex = 0;
}

// CHECK-LABEL: define dso_local void @test_null_base_fam_access_fail(
// CHECK-SAME: ptr nocapture noundef readnone [[FLEX:%.*]]) local_unnamed_addr #[[ATTR4]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR8]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void test_null_base_fam_access_fail(flex_t *__single flex) {
  flex = 0;

  flex->elems[4] = 42;
}

typedef struct {
  unsigned dummy;
  flex_t *flex;
} flex_wrapper_t;

// CHECK-LABEL: define dso_local void @test_flex_init_list_ok(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR3]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    ret void
//
void test_flex_init_list_ok() {
  char buf[4];
  flex_t *flex = (flex_t *)buf;
  flex_wrapper_t flex_wrap = {0, flex};
}

// FIXME: rdar://84809738
// CHECK-LABEL: define dso_local void @test_flex_init_list_fail(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR3]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    ret void
//
void test_flex_init_list_fail() {
  char buf[3];
  flex_t *flex = (flex_t *)buf;
  flex_wrapper_t flex_wrap = {0, flex};
}

void sink(flex_t *__single flex);

// CHECK-LABEL: define dso_local void @test_flex_argument_ok(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[BUF:%.*]] = alloca [4 x i8], align 1
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr nonnull [[BUF]]) #[[ATTR7]]
// CHECK-NEXT:    call void @sink(ptr noundef nonnull [[BUF]]) #[[ATTR7]]
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr nonnull [[BUF]]) #[[ATTR7]]
// CHECK-NEXT:    ret void
//
void test_flex_argument_ok() {
  char buf[4];
  flex_t *flex = (flex_t *)buf;
  sink(flex);
}

// FIXME: rdar://84809738
// CHECK-LABEL: define dso_local void @test_flex_argument_fail(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[BUF:%.*]] = alloca [3 x i8], align 1
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 3, ptr nonnull [[BUF]]) #[[ATTR7]]
// CHECK-NEXT:    call void @sink(ptr noundef nonnull [[BUF]]) #[[ATTR7]]
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 3, ptr nonnull [[BUF]]) #[[ATTR7]]
// CHECK-NEXT:    ret void
//
void test_flex_argument_fail() {
  char buf[3];
  flex_t *flex = (flex_t *)buf;
  sink(flex);
}
