// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --replace-value-regex "!annotation ![0-9]+" "!tbaa ![0-9]+" "!llvm.loop ![0-9]+" "#[0-9]+" --version 5

//
// RUN: %clang_cc1 -O2 -fbounds-safety -fno-bounds-safety-bringup-missing-checks=all -emit-llvm -triple x86_64 %s -o - | FileCheck %s

#include <ptrcheck.h>

struct struct_1 {
    void *value;
};

// CHECK-LABEL: define dso_local ptr @access_struct_1_all_checks_removable(
// CHECK-SAME: ptr noundef readonly [[SRC:%.*]], i32 noundef [[SIZE:%.*]], ptr noundef readnone [[VALUE:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*]]:
// CHECK-NEXT:    [[CMP_NOT23_NOT:%.*]] = icmp eq i32 [[SIZE]], 0
// CHECK-NEXT:    br i1 [[CMP_NOT23_NOT]], label %[[CLEANUP13:.*]], label %[[FOR_BODY_LR_PH:.*]]
// CHECK:       [[FOR_BODY_LR_PH]]:
// CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[SIZE]] to i64
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds nuw [[STRUCT_STRUCT_1:%.*]], ptr [[SRC]], i64 [[IDX_EXT]]
// CHECK-NEXT:    br label %[[FOR_BODY:.*]]
// CHECK:       [[FOR_COND:.*]]:
// CHECK-NEXT:    [[INDVARS_IV_NEXT:%.*]] = add nuw nsw i64 [[INDVARS_IV:%.*]], 1
// CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[IDX_EXT]]
// CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label %[[CLEANUP13]], label %[[FOR_BODY]], {{!llvm.loop ![0-9]+}}
// CHECK:       [[FOR_BODY]]:
// CHECK-NEXT:    [[INDVARS_IV]] = phi i64 [ 0, %[[FOR_BODY_LR_PH]] ], [ [[INDVARS_IV_NEXT]], %[[FOR_COND]] ]
// CHECK-NEXT:    [[BOUND_PTR_ARITH:%.*]] = getelementptr [[STRUCT_STRUCT_1]], ptr [[SRC]], i64 [[INDVARS_IV]]
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr [[BOUND_PTR_ARITH]], i64 8
// CHECK-NEXT:    [[TMP1:%.*]] = icmp ule ptr [[TMP0]], [[ADD_PTR]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[TMP2:%.*]] = icmp ule ptr [[SRC]], [[BOUND_PTR_ARITH]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[OR_COND:%.*]] = and i1 [[TMP2]], [[TMP1]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[OR_COND]], label %[[CONT1:.*]], label %[[TRAP:.*]], {{!annotation ![0-9]+}}
// CHECK:       [[TRAP]]:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) {{#[0-9]+}}, {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       [[CONT1]]:
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[BOUND_PTR_ARITH]], align 8, {{!tbaa ![0-9]+}}
// CHECK-NEXT:    [[CMP3_NOT:%.*]] = icmp eq ptr [[TMP3]], [[VALUE]]
// CHECK-NEXT:    br i1 [[CMP3_NOT]], label %[[BOUNDSCHECK_NOTNULL:.*]], label %[[FOR_COND]]
// CHECK:       [[BOUNDSCHECK_NOTNULL]]:
// CHECK-NEXT:    [[TMP4:%.*]] = icmp ult ptr [[BOUND_PTR_ARITH]], [[ADD_PTR]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP4]], label %[[CLEANUP13]], label %[[TRAP]], {{!annotation ![0-9]+}}
// CHECK:       [[CLEANUP13]]:
// CHECK-NEXT:    [[SPEC_SELECT:%.*]] = phi ptr [ [[BOUND_PTR_ARITH]], %[[BOUNDSCHECK_NOTNULL]] ], [ null, %[[ENTRY]] ], [ null, %[[FOR_COND]] ]
// CHECK-NEXT:    ret ptr [[SPEC_SELECT]]
//
struct struct_1 * access_struct_1_all_checks_removable(
    struct struct_1 *__counted_by(size) src, unsigned size, void *value) {
  for (unsigned i = 0; i < size; i++) {
    struct struct_1 *value_entry = &src[i];
    if (value_entry->value == value)
        return value_entry;
  }
  return 0;
}

// CHECK-LABEL: define dso_local ptr @access_struct_1_checks_needed(
// CHECK-SAME: ptr noundef readonly [[SRC:%.*]], i32 noundef [[SIZE:%.*]], ptr noundef readnone [[VALUE:%.*]]) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*]]:
// CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[SIZE]] to i64
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds nuw [[STRUCT_STRUCT_1:%.*]], ptr [[SRC]], i64 [[IDX_EXT]]
// CHECK-NEXT:    br label %[[FOR_COND:.*]]
// CHECK:       [[FOR_COND]]:
// CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], %[[CONT1:.*]] ], [ 0, %[[ENTRY]] ]
// CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV]], [[IDX_EXT]]
// CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label %[[CLEANUP13:.*]], label %[[FOR_BODY:.*]]
// CHECK:       [[FOR_BODY]]:
// CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
// CHECK-NEXT:    [[BOUND_PTR_ARITH:%.*]] = getelementptr [[STRUCT_STRUCT_1]], ptr [[SRC]], i64 [[INDVARS_IV_NEXT]]
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr [[BOUND_PTR_ARITH]], i64 8
// CHECK-NEXT:    [[TMP1:%.*]] = icmp ule ptr [[TMP0]], [[ADD_PTR]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[TMP2:%.*]] = icmp ule ptr [[SRC]], [[BOUND_PTR_ARITH]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[OR_COND:%.*]] = and i1 [[TMP2]], [[TMP1]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[OR_COND]], label %[[CONT1]], label %[[TRAP:.*]], {{!annotation ![0-9]+}}
// CHECK:       [[TRAP]]:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) {{#[0-9]+}}, {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       [[CONT1]]:
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[BOUND_PTR_ARITH]], align 8, {{!tbaa ![0-9]+}}
// CHECK-NEXT:    [[CMP3_NOT:%.*]] = icmp eq ptr [[TMP3]], [[VALUE]]
// CHECK-NEXT:    br i1 [[CMP3_NOT]], label %[[BOUNDSCHECK_NOTNULL:.*]], label %[[FOR_COND]]
// CHECK:       [[BOUNDSCHECK_NOTNULL]]:
// CHECK-NEXT:    [[TMP4:%.*]] = icmp ult ptr [[BOUND_PTR_ARITH]], [[ADD_PTR]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP4]], label %[[CLEANUP13]], label %[[TRAP]], {{!annotation ![0-9]+}}
// CHECK:       [[CLEANUP13]]:
// CHECK-NEXT:    [[SPEC_SELECT:%.*]] = phi ptr [ [[BOUND_PTR_ARITH]], %[[BOUNDSCHECK_NOTNULL]] ], [ null, %[[FOR_COND]] ]
// CHECK-NEXT:    ret ptr [[SPEC_SELECT]]
//
struct struct_1 * access_struct_1_checks_needed(
    struct struct_1 *__counted_by(size) src, unsigned size, void *value) {
  for (unsigned i = 0; i < size; i++) {
    struct struct_1 *value_entry = &src[i+1];
    if (value_entry->value == value)
        return value_entry;
  }
  return 0;
}

struct struct_2 {
    int a;
    int b;
};

// CHECK-LABEL: define dso_local ptr @access_struct_2_all_checks_removable(
// CHECK-SAME: ptr noundef readonly [[SRC:%.*]], i32 noundef [[SIZE:%.*]], i32 noundef [[A:%.*]], i32 noundef [[B:%.*]]) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*]]:
// CHECK-NEXT:    [[CMP_NOT37_NOT:%.*]] = icmp eq i32 [[SIZE]], 0
// CHECK-NEXT:    br i1 [[CMP_NOT37_NOT]], label %[[CLEANUP24:.*]], label %[[FOR_BODY_LR_PH:.*]]
// CHECK:       [[FOR_BODY_LR_PH]]:
// CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[SIZE]] to i64
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds nuw [[STRUCT_STRUCT_2:%.*]], ptr [[SRC]], i64 [[IDX_EXT]]
// CHECK-NEXT:    br label %[[FOR_BODY:.*]]
// CHECK:       [[FOR_BODY]]:
// CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, %[[FOR_BODY_LR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], %[[FOR_INC:.*]] ]
// CHECK-NEXT:    [[BOUND_PTR_ARITH:%.*]] = getelementptr [[STRUCT_STRUCT_2]], ptr [[SRC]], i64 [[INDVARS_IV]]
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr [[BOUND_PTR_ARITH]], i64 8
// CHECK-NEXT:    [[TMP1:%.*]] = icmp ule ptr [[TMP0]], [[ADD_PTR]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[TMP2:%.*]] = icmp ule ptr [[SRC]], [[BOUND_PTR_ARITH]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[OR_COND:%.*]] = and i1 [[TMP2]], [[TMP1]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[OR_COND]], label %[[CONT1:.*]], label %[[TRAP:.*]], {{!annotation ![0-9]+}}
// CHECK:       [[TRAP]]:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) {{#[0-9]+}}, {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       [[CONT1]]:
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[BOUND_PTR_ARITH]], align 4, {{!tbaa ![0-9]+}}
// CHECK-NEXT:    [[CMP3:%.*]] = icmp eq i32 [[TMP3]], [[A]]
// CHECK-NEXT:    br i1 [[CMP3]], label %[[CONT12:.*]], label %[[FOR_INC]]
// CHECK:       [[CONT12]]:
// CHECK-NEXT:    [[B13:%.*]] = getelementptr inbounds nuw i8, ptr [[BOUND_PTR_ARITH]], i64 4
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[B13]], align 4, {{!tbaa ![0-9]+}}
// CHECK-NEXT:    [[CMP14:%.*]] = icmp eq i32 [[TMP4]], [[B]]
// CHECK-NEXT:    br i1 [[CMP14]], label %[[BOUNDSCHECK_NOTNULL:.*]], label %[[FOR_INC]]
// CHECK:       [[BOUNDSCHECK_NOTNULL]]:
// CHECK-NEXT:    [[TMP5:%.*]] = icmp ult ptr [[BOUND_PTR_ARITH]], [[ADD_PTR]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP5]], label %[[CLEANUP24]], label %[[TRAP]], {{!annotation ![0-9]+}}
// CHECK:       [[FOR_INC]]:
// CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
// CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[IDX_EXT]]
// CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label %[[CLEANUP24]], label %[[FOR_BODY]], {{!llvm.loop ![0-9]+}}
// CHECK:       [[CLEANUP24]]:
// CHECK-NEXT:    [[SPEC_SELECT:%.*]] = phi ptr [ [[BOUND_PTR_ARITH]], %[[BOUNDSCHECK_NOTNULL]] ], [ null, %[[ENTRY]] ], [ null, %[[FOR_INC]] ]
// CHECK-NEXT:    ret ptr [[SPEC_SELECT]]
//
struct struct_2 * access_struct_2_all_checks_removable(
    struct struct_2 *__counted_by(size) src, unsigned size, int a, int b) {
  for (unsigned i = 0; i < size; i++) {
   struct struct_2 *value_entry = &src[i];
    if (value_entry->a == a && value_entry->b == b)
        return value_entry;
  }
    return 0;
}

typedef struct {
  int f1;
  int f2;
  int f3;
} MyStruct;

// All runtime checks in the loop can be removed.
// CHECK-LABEL: define dso_local i32 @array_of_structs_all_checks_removable(
// CHECK-SAME: ptr noundef readonly [[ITEMS:%.*]], i32 noundef [[NUMITEMS:%.*]]) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*]]:
// CHECK-NEXT:    [[CMP29_NOT:%.*]] = icmp eq i32 [[NUMITEMS]], 0
// CHECK-NEXT:    br i1 [[CMP29_NOT]], label %[[FOR_COND_CLEANUP:.*]], label %[[FOR_BODY_LR_PH:.*]]
// CHECK:       [[FOR_BODY_LR_PH]]:
// CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[NUMITEMS]] to i64
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds nuw [[STRUCT_MYSTRUCT:%.*]], ptr [[ITEMS]], i64 [[IDX_EXT]]
// CHECK-NEXT:    br label %[[FOR_BODY:.*]]
// CHECK:       [[FOR_COND_CLEANUP]]:
// CHECK-NEXT:    [[RES_0_LCSSA:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[ADD21:%.*]], %[[CONT19:.*]] ]
// CHECK-NEXT:    ret i32 [[RES_0_LCSSA]]
// CHECK:       [[FOR_BODY]]:
// CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, %[[FOR_BODY_LR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], %[[CONT19]] ]
// CHECK-NEXT:    [[RES_031:%.*]] = phi i32 [ 0, %[[FOR_BODY_LR_PH]] ], [ [[ADD21]], %[[CONT19]] ]
// CHECK-NEXT:    [[BOUND_PTR_ARITH:%.*]] = getelementptr [[STRUCT_MYSTRUCT]], ptr [[ITEMS]], i64 [[INDVARS_IV]]
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr [[BOUND_PTR_ARITH]], i64 12
// CHECK-NEXT:    [[TMP1:%.*]] = icmp ule ptr [[TMP0]], [[ADD_PTR]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[TMP2:%.*]] = icmp ule ptr [[ITEMS]], [[BOUND_PTR_ARITH]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[OR_COND:%.*]] = and i1 [[TMP2]], [[TMP1]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[OR_COND]], label %[[CONT19]], label %[[TRAP:.*]], {{!annotation ![0-9]+}}
// CHECK:       [[TRAP]]:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) {{#[0-9]+}}, {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       [[CONT19]]:
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[BOUND_PTR_ARITH]], align 4, {{!tbaa ![0-9]+}}
// CHECK-NEXT:    [[F2:%.*]] = getelementptr inbounds nuw i8, ptr [[BOUND_PTR_ARITH]], i64 4
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[F2]], align 4, {{!tbaa ![0-9]+}}
// CHECK-NEXT:    [[F3:%.*]] = getelementptr inbounds nuw i8, ptr [[BOUND_PTR_ARITH]], i64 8
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[F3]], align 4, {{!tbaa ![0-9]+}}
// CHECK-NEXT:    [[ADD:%.*]] = add i32 [[TMP3]], [[RES_031]]
// CHECK-NEXT:    [[ADD20:%.*]] = add i32 [[ADD]], [[TMP4]]
// CHECK-NEXT:    [[ADD21]] = add i32 [[ADD20]], [[TMP5]]
// CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
// CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[IDX_EXT]]
// CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label %[[FOR_COND_CLEANUP]], label %[[FOR_BODY]], {{!llvm.loop ![0-9]+}}
//
int array_of_structs_all_checks_removable(MyStruct *__counted_by(numItems) items,
                                unsigned numItems) {
  int res = 0;
  for (unsigned i = 0; i < numItems; i++) {
    const MyStruct *ptr = &items[i];
    res += ptr->f1 + ptr->f2 + ptr->f3;
  }
  return res;
}
